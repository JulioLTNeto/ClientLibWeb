	Criando um projeto simples
Vamos fazer um simples projeto no qual integra Arduino e Desktop. Nesse projeto vamos ter um Tópico chamado “Luminosidade” no qual ambos os lados (do Arduino e do computador) vão estar inscritos. Nesse exemplo, o Arduino ficará notificando, a cada 5 segundos, a intensidade luminosa no ambiente em que está inserido.
Desta forma, caso queira fazer você mesmo o projeto, tenha em mãos:
•	Placa Arduino Wemos (já é integrada com um módulo ESP8266)
•	Uma protoboard
•	Um resistor de 100k?
•	Um LDR
•	Alguns jumpers
Faça as ligações da seguinte forma:
<img src="../img/imgTuto.png"></img>
Não há problema caso você não tenha uma placa Wemos, desde que tenha um módulo ESP8266. Em ambos os casos, faz-se necessário que você possua a biblioteca ESP8266WiFi instalada e configurada na sua IDE.
Partindo para o código, cabem algumas ressalvas:
•	É necessária a implementação de um método que será executado quando o ESP registrar uma informação recebida.
•	Da mesma forma, é necessária a implementação de um método que será executado quando o ESP se conectar ao servidor do ContextNet. 
•	E por fim, é necessária a implementação de um método responsável por publicar informações no ContextNet.
Desta forma, daremos início implementando o método NovaInformacaoRecebida:
void NovaInformacaoRecebida(const tInformation info){
    Serial.printf("--------InformationData--------\n");
    Serial.printf("Information class: %s\n", GetInformationTopic(info));

    int i = 0;
    const char *k;
    const char *v;
    Serial.printf("Informations:\n");
    while(1){
        k = GetInformationKey(info, i);
        v = GetInformationByIndex(info, i);
        if (!k || !v){
            break;
        }
        Serial.printf("\t\"%s\" = \"%s\"\n", k, v);
        i++;
    }

    i = 0;
    Serial.printf("Properties:\n");
    while(1){
        k = GetPropertyKey(info, i);
        v = GetPropertyByIndex(info, i);
        if (!k || !v){
            break;
        }
        Serial.printf("\t\"%s\" = \"%s\"\n", k, v);
        i++;
    }
    Serial.printf("--------------------------------\n");
}
Vamos dissecar todo o código. Primeiramente note o parâmetro recebido: tInformation. Ele nada mais é que um tipo que representa um tópico, onde estão todas as suas informações.
Em seguida o GetInformationTopic(info), dentro do Serial.println. Esse método retorna simplesmente o tópico que foi recebido. 
Depois disso, note que há um loop while que percorre até que não haja nada lido por GetInformationKey ou GetInformationByIndex. Isso simplesmente percorre todas as informações que existem na informação recebida, onde o GetInformationKey(info,i) é um método da ClientLib que retorna a chave, isto é, o nome de um item de informação incluída no tópico recebido. Da mesma forma, o GetInformationByIndex(info,i) recebe o valor em si do item de informação recebida. Resumindo, o loop do while vai imprimir todas as informações incluídas no tópico.
Após isso, há outro loop que também utiliza as variáveis k e v. Desta vez, os métodos da ClientLib utilizados no loop são GetPropertyKey(info, i) e GetPropertyByIndex(info, i), e como sugere o nome da função, elas retornam as propriedades da informação recebida, onde a GetPropertyKey retorna o nome da propriedade e o GetPropertyByIndex retorna o valor da propriedade.
Vale lembrar que essa é uma função que será chamada pela ClientLib quando o Arduino identificar uma nova informação recebida.
Agora vamos à próxima função: NovaPublicacao.
void NovaPublicacao(const char *topic){
    Serial.printf("Nova Publicacao em: \"%s\".\n", topic);


    tInformation info = NewInformation();
    SetInformationTopic(info, topic);
    SetMainInformation(info, (char*)luminosidade);
    AddInformation(info, "bairro", "mangabeira");

    ClientLibPublish(info);
    FreeInformation(info);
}
Essa a função que implementamos para enviar uma nova informação. Note que ela recebe como parâmetro o nome do tópico no qual você está publicando. Da mesma forma, você inicializa o tInformation, através do NewInformation(). 
Feito isso, você informa para o tInformation o nome do tópico no qual você está publicando a informação através do SetInformationTopic(info,topic), onde info é a informação que você acabou de criar, e o topic é o nome do tópico onde você realizará a publicação.
Após isso você diz ao tInformation qual a informação principal que você estará publicando, através da SetMainInformation(info,(char*)luminosidade). Note que a informação precisa ser um array de bytes, logo deve ser feito um cast no int que representa a leitura do sensor na luminosidade.
Ainda é possível incluir informações adicionais na tInformation. Nesse caso, foi incluído o nome do bairro, sem esquecer, claro, de informar o nome da informação que você está adicionando e o valor que ela receberá.
Por fim, então, é feita a publicação com a função ClientLibPublish(info) e por fim é usada a função FreeInformation(info) que libera espaço na memória.
Agora vamos à função Conectado, que será chamada após a ClientLib se conectar ao ContextNet:
void Conectado(int result){
  if(result){
    ClientLibSubscribe("clock", NovaInformacaoRecebida);
    ClientLibSubscribe("temperature", NovaInformacaoRecebida);
    ClientLibSubscribe("presence",NovaInformacaoRecebida);
    ClientLibRegisterPublisher("luminosidade",NovaPublicacao);
  }else{
    Serial.println("Falha na conexao");
  }
}
Primeiramente note o parâmetro result, que representa se a conexão teve ou não sucesso. Então, caso não tenha tido sucesso, é mostrada uma mensagem indicando a falha na conexão. Mas caso contrário duas funções da clientLib são utilizadas:
•	ClientLibSubscribe, que inscreve o dispositivo para receber informações de algum tópico (nesse caso receberá informações de clock, temperatura e presença). 
•	ClientLibRegisterPublisher, que informa ao ClientLib que seu dispositivo irá publicar informações de algum tópico (no caso, luminosidade).
Agora vamos explorar as funções padrões do Arduino: setup e loop.
void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin("RESIDENCIA_LUCAS", "lucasfreitas115");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }  
  ClientLibInit();
  ClientLibConnect("10.0.0.100", 5500, Conectado);
  
  pinMode(SENSOR, INPUT);
  
}
Primeiramente usamos a frequência utilizada pelo ESP para comunicação serial: 115200. Feito isso, configura o tipo de conexão como WIFI_STA e é feita a conexão WiFi usando o nome da rede e a senha. Então aguarda-se que a conexão seja estabelecida. 
Quando é estabelecida a conexão com o WiFi, inicializa-se o ClientLib, através do ClientLibInit(). Feito isso, conecta a ClientLib ao ContextNet, inserindo o IP e a porta de onde ela está conectada.
Não podemos esquecer de informar que o sensor de luminosidade está em modo de entrada.
Por fim, vamos avaliar a função de loop:
long lastTime = millis();
bool state = false;
void loop() {
  if (ClientLibIsActive()){
      ClientLibUpdate();
      if(millis() > (lastTime-5000)){
        lastTime = millis();
        luminosidade = analogRead(SENSOR);
        NovaPublicacao("luminosidade");
      }
      state = false;
  }else{
    ClientLibShutdown();  
    if(!state){
      Serial.println("Desconectado");
      state = true;
    }
  }
}
A variável lastTime funciona para ter um controle de que seja feita uma nova publicação a cada 5 segundos. Dentro do void loop, primeiro é feito um teste de que o ClientLib esteja ativo. Caso esteja ativo, ele atualiza. Feita a leitura do sensor, o valor da variável luminosidade é atualizado (verifica se não há novos dados recebidos) e é feita uma nova publicação no tópico luminosidade.
Caso o ClientLib esteja inativo, ele é desligado. A variável state é utilizada apenas para ter um controle de que a mensagem “Desconectado” seja mostrada apenas uma vez no Serial monitor do Arduino.
Desta forma, o código inteiro para este projeto no Arduino é o seguinte:
#include <ESP8266WiFi.h>
#include <clientlib.h>

#define SENSOR A0

int luminosidade;

void NovaInformacaoRecebida(const tInformation info){
    Serial.printf("--------InformationData--------\n");
    Serial.printf("Information class: %s\n", GetInformationTopic(info));

    int i = 0;
    const char *k;
    const char *v;
    Serial.printf("Informations:\n");
    while(1){
        k = GetInformationKey(info, i);
        v = GetInformationByIndex(info, i);
        if (!k || !v){
            break;
        }
        Serial.printf("\t\"%s\" = \"%s\"\n", k, v);
        i++;
    }

    i = 0;
    Serial.printf("Properties:\n");
    while(1){
        k = GetPropertyKey(info, i);
        v = GetPropertyByIndex(info, i);
        if (!k || !v){
            break;
        }
        Serial.printf("\t\"%s\" = \"%s\"\n", k, v);
        i++;
    }
    Serial.printf("--------------------------------\n");
}
void NovaPublicacao(const char *topic){
    Serial.printf("Nova Publicacao em: \"%s\".\n", topic);


    tInformation info = NewInformation();
    SetInformationTopic(info, topic);
    SetMainInformation(info, (char*)luminosidade);
    AddInformation(info, "bairro", "mangabeira");

    ClientLibPublish(info);
    FreeInformation(info);
}
void Conectado(int result){
  if(result){
    ClientLibSubscribe("clock", NovaInformacaoRecebida);
    ClientLibSubscribe("temperature", NovaInformacaoRecebida);
    ClientLibSubscribe("presence",NovaInformacaoRecebida);
    ClientLibRegisterPublisher("luminosidade",NovaPublicacao);
  }else{
    Serial.println("Falha na conexao");
  }
}
void setup() {
  Serial.begin(115200);
  WiFi.mode(WIFI_STA);
  WiFi.begin("RESIDENCIA_LUCAS", "lucasfreitas115");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
  }  
  ClientLibInit();
  ClientLibConnect("10.0.0.100", 5500, Conectado);
  
  pinMode(SENSOR, INPUT);
  
}
long lastTime = millis();
bool state = false;
void loop() {
  if (ClientLibIsActive()){
      ClientLibUpdate();
      if(millis() > (lastTime-5000)){
        lastTime = millis();
        luminosidade = analogRead(SENSOR);
        NovaPublicacao("luminosidade");
      }
      state = false;
  }else{
    ClientLibShutdown();  
    if(!state){
      Serial.println("Desconectado");
      state = true;
    }
  }
}
Agora no lado do Desktop, pressupondo que você já tenha configurado adequadamente a biblioteca ClientLib, não está muito distante do que implementamos no Arduino. As funções de NovaInformacaoRecebida, NovaPublicacao e Conectado não mudam muito em relação ao do Arduino. As funções da clientLib utilizadas em ambos é a mesma, sendo um diferencial da biblioteca, ter uma portabilidade entre o microcontrolador Arduino e um programa em C. Sendo assim, vamos começar pela função NovaInformacaoRecebida:
void NovaInformacaoRecebida(const tInformation info){
    printf("--------InformationData--------\n");
    printf("Information class: %s\n", GetInformationTopic(info));

    int i = 0;
    const char *k;
    const char *v;
    printf("Informations:\n");
    while(1){
        k = GetInformationKey(info, i);
        v = GetInformationByIndex(info, i);
        if (!k || !v){
            break;
        }
        printf("\t\"%s\" = \"%s\"\n", k, v);
        i++;
    }

    i = 0;
    printf("Properties:\n");
    while(1){
        k = GetPropertyKey(info, i);
        v = GetPropertyByIndex(info, i);
        if (!k || !v){
            break;
        }
        printf("\t\"%s\" = \"%s\"\n", k, v);
        i++;
    }
    printf("--------------------------------\n");
}
Note que a única diferença entre esse código e o código da mesma função no Arduino é que ao invés do uso do Serial.println, há o uso do printf. Portanto, não há a necessidade de uma nova explanação.
void NovaPublicacao(const char *topic){
    printf("Nova Inscricao em: \"%s\".\n", topic);

    tInformation info = NewInformation();
    SetInformationTopic(info, "clock");
    SetMainInformation(info, "4:20");
    AddInformation(info, "bairro", "mangabeira");

    ClientLibPublish(info);
    FreeInformation(info);
}
Note que aqui é enviado por padrão apenas um valor aleatório de horário, apenas para fins didáticos. Mas, assim como no Arduino, não há diferença alguma no código a não ser o printf no lugar de Serial.println. Desta forma, esse trecho de código também dispensa novas explicações.
void Conectado(int result){
    if(result){
        printf("Conectou!\n");

        ClientLibSubscribe("clock", NovaInformacaoRecebida);
        ClientLibSubscribe("temperature", NovaInformacaoRecebida);
        ClientLibSubscribe("luminosidade", NovaInformacaoRecebida);
        ClientLibRegisterPublisher("clock", NovaPublicacao);
    }else{
        printf("Falha na conexão");
    }
}
Tal qual no Arduino, o sistema Desktop se inscreveu nos tópicos de clock, temperature e luminosidade, porém publica informações de clock. Assim como no Arduino, também, não há diferenças significativas além do printf no lugar do Serial.println.
Por fim, vamos a função main:
int main(){
    ClientLibInit();
    ClientLibConnect("10.0.0.100", 5500, Conectado);

    while (ClientLibIsActive()){
        ClientLibUpdate();
    }

    ClientLibShutdown();

    return 0;
}
Na função main, a ClientLib é iniciada, é feita a conexão com a ContextNet, e enquanto a ClientLib está ativa, é esperado o recebimento de alguma informação em algum tópico no qual esteja assinado.
Quando a ClientLib não estiver mais ativa, o método ClientLibShutdown é chamado. Desta forma, o código completo é como segue-se abaixo:
#include <stdio.h>
#include <stdlib.h>

#include "clientlib.h"

void NovaInformacaoRecebida(const tInformation info){
    printf("--------InformationData--------\n");
    printf("Information class: %s\n", GetInformationTopic(info));

    int i = 0;
    const char *k;
    const char *v;
    printf("Informations:\n");
    while(1){
        k = GetInformationKey(info, i);
        v = GetInformationByIndex(info, i);
        if (!k || !v){
            break;
        }
        printf("\t\"%s\" = \"%s\"\n", k, v);
        i++;
    }

    i = 0;
    printf("Properties:\n");
    while(1){
        k = GetPropertyKey(info, i);
        v = GetPropertyByIndex(info, i);
        if (!k || !v){
            break;
        }
        printf("\t\"%s\" = \"%s\"\n", k, v);
        i++;
    }
    printf("--------------------------------\n");
}
void NovaPublicacao(const char *topic){
    printf("Nova Inscricao em: \"%s\".\n", topic);

    tInformation info = NewInformation();
    SetInformationTopic(info, "clock");
    SetMainInformation(info, "4:20");
    AddInformation(info, "bairro", "mangabeira");

    ClientLibPublish(info);
    FreeInformation(info);
}
void Conectado(int result){
    if(result){
        printf("Conectou!\n");

        ClientLibSubscribe("clock", NovaInformacaoRecebida);
        ClientLibSubscribe("temperature", NovaInformacaoRecebida);
        ClientLibSubscribe("luminosidade", NovaInformacaoRecebida);
        ClientLibRegisterPublisher("clock", NovaPublicacao);
    }else{
        printf("Falha na conexão");
    }
}
int main(){
    ClientLibInit();
    ClientLibConnect("10.0.0.100", 5500, Conectado);

    while (ClientLibIsActive()){
        ClientLibUpdate();
    }

    ClientLibShutdown();

    return 0;
}
